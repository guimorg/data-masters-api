"""Creating routes for the API"""
import json
import inspect
import asyncio

import fastjsonschema

from aiohttp import web
from aiohttp.web_exceptions import (
    HTTPMethodNotAllowed,
    HTTPInternalServerError,
    HTTPBadRequest
)

from api import (
    log,
    model
)


_logger = log.get_logger()

DEFAULT_METHODS = ['GET', 'POST']


class Endpoint:
    """
    Base Class for Endpoints.
    Automatically register all methods in Endpoint
    """
    def __init__(self):
        self.methods = {}
        _logger.debug(f'Initializing Endpoint {self.__class__.__name__}')

        for method_name in DEFAULT_METHODS:
            method = getattr(self, method_name.lower(), None)
            if method:
                self.register_method(method_name, method)

    def register_method(self, method_name, method):
        _logger.debug(f'Adding {method_name} to {self.__class__.__name__}')
        self.methods[method_name.upper()] = method

    async def dispatch(self, request):
        method = self.methods.get(request.method.upper())
        if not method:
            _logger.warning(
                f'Method {request.method.upper()} not allowed'
                f' in {self.__class__.__name__}!'
            )
            raise HTTPMethodNotAllowed('', DEFAULT_METHODS)

        # Checking if args are available in method
        _logger.debug('Checking args...')
        required_args = list(inspect.signature(method).parameters.keys())
        given_args = request.match_info.copy()
        given_args.update({'request': request})

        unsatisfied_args = set(required_args) - set(given_args.keys())
        if unsatisfied_args:
            # If required args are not provided raises BadRequest Exc
            _logger.error(f'Unsatisfied args: {unsatisfied_args}')
            raise HTTPBadRequest('')

        return await method(
            **{arg_name: given_args[arg_name]
               for arg_name in given_args}
        )


class HealthCheck(Endpoint):
    """
    HealthCheck of Application.
    """
    async def get(self, request):
        # Application is Up and Running!
        _logger.info('HealthCheck was called! Everything is ok!')
        return web.Response(
            status=200,
            content_type='application/json',
            body=json.dumps({'status': 'running'})
        )


class MachineLearning(Endpoint):
    """
    Machine Learning Prediction.
    """
    def __init__(
        self,
        schema_in,
        schema_out,
        executor
    ):
        super().__init__()
        # Compile json schema
        _logger.debug('Compiling JSON Schema Function...')
        self.val_fun_in = self._compile_json_schema(schema_in)
        self.val_fun_out = self._compile_json_schema(schema_out)
        # Configuring Loop and Executors
        _logger.debug('Executor and Async Loop')
        self._loop = asyncio.get_event_loop()
        self._executor = executor

    async def post(self, request):
        data = await request.json()
        # We need first to validate our data
        if not self._validate_data(data, self.val_fun_in):
            return web.HTTPBadRequest(
                text='Data does not comply with contract!'
            )

        _logger.debug('Giving data to model because everything checks ok!')
        r = self._loop.run_in_executor
        prediction = await r(self._executor, model.score, data)

        # Checking if model responded well
        if not self._validate_data(prediction, self.val_fun_out):
            _logger.error(
                f'Model got itself in trouble, {prediction}'
                'does not comply with contract'
            )
            return HTTPInternalServerError(
                text='Output data does not comply with schema'
            )

        return web.Response(
            status=200,
            content_type='application/json',
            body=json.dumps(
                {'prediction': prediction}
            )
        )

    @staticmethod
    def _validate_data(data, val_fun):
        """
        Validating Data before Predicting.
        """
        _logger.debug('Validating data using JSON schema')
        try:
            val_fun(data)
        except Exception as err:
            _logger.error(f'Data does not comply with JSON schema!')
            _logger.error(f'{err}')
            # Exception generated by Failure in Validation
            # means that does not comply with schema
            return False
        _logger.debug('Data comply with JSON schema!')
        return True

    @staticmethod
    def _compile_json_schema(json_schema_path):
        """
        Compiling JSON Schema to faster validation.
        """
        with open(json_schema_path, 'rb') as fd:
            json_from_dict = json.load(fd)
        val_fun = fastjsonschema.compile(json_from_dict)
        return val_fun
